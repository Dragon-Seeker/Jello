plugins {
	id "fabric-loom" version "0.12-SNAPSHOT"
	id "io.github.juuxel.loom-quiltflower" version "1.7.3" // Quiltflower, a better decompiler
//	id "io.github.p03w.machete" version "1.+" // automatic jar compressing on build
	id "maven-publish"
}

sourceCompatibility = JavaVersion.VERSION_17
targetCompatibility = JavaVersion.VERSION_17

archivesBaseName = project.archives_base_name

def moduleDependencies(project, List<String> depNames) {
	def deps = depNames.iterator().collect { project.dependencies.project(path: ":$it", configuration: 'namedElements') }

	project.dependencies {
		deps.each {
			api it
		}
	}

	// As we manually handle the maven artifacts, we need to also manually specify the deps.
	project.publishing {
		publications {
			if (project.archivesBaseName == "jello" || project.archivesBaseName == "gelatin") return

			mavenJava(MavenPublication) {
				pom.withXml {
					def depsNode = asNode().appendNode("dependencies")
					deps.each {
						def depNode = depsNode.appendNode("dependency")
						depNode.appendNode("groupId", it.group)
						depNode.appendNode("artifactId", it.name)
						depNode.appendNode("version", it.version)
						depNode.appendNode("scope", "compile")
					}
				}
			}
		}
	}
}

File globalAccessWidener = file("src/main/resources/gelatin.accesswidener")

allprojects {
	apply plugin: "fabric-loom"
	apply plugin: "maven-publish"

	group = project.maven_group
	version = ("${project.mod_version}+${project.minecraft_version}")

//	tasks.withType(GenerateModuleMetadata) {
//		enabled = false
//	}

	tasks.withType(JavaCompile).configureEach { it.options.release = 17 }

	java {
		withSourcesJar()
	}

	repositories {
		maven { url "https://maven.wispforest.io" }
		maven { url "https://maven.shedaniel.me/" }
		maven { url "https://jitpack.io"}
		maven { name = "Modrinth"
			url "https://api.modrinth.com/maven"
			content {includeGroup "maven.modrinth" }
		}
		maven {
			url "https://cursemaven.com"
			content {includeGroup "curse.maven" }
		}
		maven {
			url "https://maven.terraformersmc.com/releases/"
			content {includeGroup "com.terraformersmc" }
		}
		mavenLocal()
		mavenCentral()
	}

	dependencies {
		minecraft("com.mojang:minecraft:${project.minecraft_version}")
		mappings("net.fabricmc:yarn:${project.yarn_mappings}:v2")
		modImplementation("net.fabricmc:fabric-loader:${project.loader_version}")

		implementation("javax.annotation:javax.annotation-api:1.3.2")
		modImplementation("net.fabricmc.fabric-api:fabric-api:${project.fabric_version}")

		//-----------------

		modImplementation "io.wispforest:owo-lib:${project.owo_version}"

		//-----------------

		modCompileOnly("com.terraformersmc:modmenu:${project.modmenu}")
		modLocalRuntime("com.terraformersmc:modmenu:${project.modmenu}")

		//-----------------

		modImplementation("me.shedaniel.cloth:cloth-config-fabric:${project.cloth_config}"){
			exclude(group: "net.fabricmc.fabric-api")
		}

		// Optional Compat Mods



//    modImplementation "maven.modrinth:consistencyplus:${project.consistencyplus}"
		// Local Mods

		modLocalRuntime("maven.modrinth:ferrite-core:${project.ferrite_core}-fabric")

//    modImplementation("maven.modrinth:lithium:${project.lithium}")
//    modLocalRuntime("maven.modrinth:lithium:${project.lithium}")

		modImplementation("maven.modrinth:sodium:${project.sodium}")
		modLocalRuntime("maven.modrinth:sodium:${project.sodium}")

		modImplementation('org.joml:joml:1.10.2')
		modLocalRuntime('org.joml:joml:1.10.2')

		modLocalRuntime("maven.modrinth:starlight:${project.starlight}")

		modLocalRuntime("maven.modrinth:lazydfu:${project.lazydfu}")
	}

	allprojects.each { p ->
		loom.mods.register(p.name) {
			sourceSet p.sourceSets.main
		}
	}

	loom {
		accessWidenerPath = globalAccessWidener

		runtimeOnlyLog4j = true

		runs {
			client {
				client()
				ideConfigGenerated project.rootProject == project
				name = "[${project.name}] Client"
				source sourceSets.main
			}
			server {
				server()
				ideConfigGenerated project.rootProject == project
				name = "[${project.name}] Server"
				source sourceSets.main
			}
		}
	}

	tasks.withType(ProcessResources).configureEach { proccess ->
		inputs.property "version", project.version

		filesMatching("fabric.mod.json") {
			expand "version": project.version
		}
	}

	tasks.withType(AbstractArchiveTask) {
		preserveFileTimestamps = false
		reproducibleFileOrder = true
	}

	tasks.withType(JavaCompile).configureEach {
		it.options.release = Integer.parseInt(sourceCompatibility)
	}

	jar {
		from("LICENSE") {
			rename { "${it}_${project.archivesBaseName}" }
		}
	}
}

javadoc {
	options {
		source = "17"
		encoding = "UTF-8"
		charSet = "UTF-8"
		memberLevel = JavadocMemberLevel.PACKAGE
		links(
				"https://guava.dev/releases/21.0/api/docs/",
				"https://asm.ow2.io/javadoc/",
				"https://docs.oracle.com/javase/8/docs/api/",
				"http://jenkins.liteloader.com/job/Mixin/javadoc/",
				"https://logging.apache.org/log4j/2.x/log4j-api/apidocs/"
				// Need to add minecraft jd publication etc once there is one available
		)
		// Disable the crazy super-strict doclint tool in Java 8
		addStringOption("Xdoclint:none", "-quiet")
	}

	allprojects.each { project ->
		if(project.archivesBaseName == "jello" || project.archivesBaseName == "gelatin") return

		source(project.sourceSets.main.allJava.srcDirs)
	}

	classpath = files(sourceSets.main.compileClasspath)
	include("**/api/**")
	failOnError false
}

//task javadocJar(type: Jar) {
//	dependsOn javadoc
//	from javadoc.destinationDir
//	//Set as `fatjavadoc` to prevent an ide form trying to use this javadoc, over using the modules javadoc
//	archiveClassifier = "fatjavadoc"
//}
//
//build.dependsOn javadocJar

subprojects.each {project ->
	if(project.archivesBaseName == "jello") return

	remapJar.dependsOn("${project.path}:remapJar")
}

//dependencies {
//	afterEvaluate {
//		subprojects.each {project ->
//			if(project.archivesBaseName == "jello") return
//
//			api project.configurations.getByName("namedElements") //project(path: "${project.path}", configuration: "namedElements")
//		}
//	}
//}

remapJar {
	afterEvaluate {
		subprojects.each {project ->
			if(project.archivesBaseName == "jello") return

			nestedJars.from project.tasks.getByName("remapJar")
		}
	}
}

void setupRepositories(RepositoryHandler repositories) {
	//repositories.mavenLocal() // uncomment for testing

	def ENV = System.getenv()
	repositories.maven {
		url ENV.MAVEN_URL

		credentials {
			username ENV.MAVEN_USER
			password ENV.MAVEN_PASSWORD
		}
	}
}

subprojects {
	publishing {
		if (project.archivesBaseName == "jello") return

		//System.out.println("Publishing Out: " + project.archivesBaseName.toString() + project.version.toString())

		setupRepositories(repositories)

		publications {
			release(MavenPublication) {
//				artifact(remapMavenJar) {
//					builtBy(remapMavenJar)
//				}

//				artifact(remapSourcesJar) {
//					builtBy remapSourcesJar
//				}

				from components.java

				artifactId = project.archivesBaseName
				groupId = project.group
				version = project.version
			}
		}
	}

	afterEvaluate {
		afterEvaluate {
			genSourcesWithQuiltflower.enabled = false
			genSourcesWithFernFlower.enabled = false
			genSourcesWithCfr.enabled = false
			unpickJar.enabled = false
			downloadAssets.enabled = false
		}
	}
}

task remapMavenJar(type: net.fabricmc.loom.task.RemapJarTask, dependsOn: jar) {
	input = jar.archiveFile
	archiveFileName = "${archivesBaseName}-${project.version}-maven.jar" //
	addNestedDependencies = false
}
//build.dependsOn remapMavenJar

publishing {
	publications {
		mavenJava(MavenPublication) {
			pom.withXml {
				def depsNode = asNode().appendNode("dependencies")
				subprojects.each {
					if (it.archivesBaseName == "jello" || it.archivesBaseName == "gelatin") return//if(project.archivesBaseName == "jello") return

					def depNode = depsNode.appendNode("dependency")
					depNode.appendNode("groupId", it.group)
					depNode.appendNode("artifactId", it.name)
					depNode.appendNode("version", it.version)
					depNode.appendNode("scope", "compile")
				}
			}
		}
	}
}

